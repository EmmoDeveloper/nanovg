#version 450

// GPU MSDF Generation - Multi-Channel Signed Distance Field from Glyph Outlines
// Based on Chlumsky's msdfgen algorithm
// Input: Glyph outline (Bezier contours)
// Output: RGB MSDF texture (3 channels, each containing SDF from different edge subset)

layout(local_size_x = 8, local_size_y = 8) in;

// Glyph outline data (matches VKNVGoutlinePoint/VKNVGoutlineContour)
struct OutlinePoint {
	vec2 pos;		// Normalized coordinates (0-1 range)
	uint onCurve;	// 1 if on-curve, 0 if control point
	uint padding;
};

struct OutlineContour {
	OutlinePoint points[128];	// VKNVG_MAX_POINTS_PER_CONTOUR
	uint pointCount;
	uint padding;
};

// Input buffer: glyph outline data
layout(std430, binding = 0) readonly buffer OutlineBuffer {
	uint contourCount;
	uint unitsPerEM;
	int bearingX;
	int bearingY;
	uint advance;
	uint width;
	uint height;
	uint padding;
	OutlineContour contours[32];	// VKNVG_MAX_CONTOURS
} outline;

// Output image: RGB MSDF texture
layout(binding = 1, rgba8) uniform writeonly image2D outputMSDF;

// Push constants for parameters
layout(push_constant) uniform Params {
	uint outputWidth;	// Output texture width
	uint outputHeight;	// Output texture height
	float pxRange;		// Pixel range for SDF (typically 4.0)
	float padding;
} params;

// Signed distance from point to line segment
float sdSegment(vec2 p, vec2 a, vec2 b) {
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
	return length(pa - ba * h);
}

// Signed distance from point to quadratic Bezier
float sdBezier(vec2 p, vec2 p0, vec2 p1, vec2 p2) {
	vec2 a = p1 - p0;
	vec2 b = p0 - 2.0 * p1 + p2;
	vec2 c = a * 2.0;
	vec2 d = p0 - p;

	// Solve for closest point on curve
	float kk = 1.0 / dot(b, b);
	float kx = kk * dot(a, b);
	float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;
	float kz = kk * dot(d, a);

	float res = 0.0;
	float sgn = 0.0;

	float p_param = ky - kx * kx;
	float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;
	float p3 = p_param * p_param * p_param;
	float q2 = q * q;
	float h = q2 + 4.0 * p3;

	if (h >= 0.0) {
		// 1 real root
		h = sqrt(h);
		vec2 x = (vec2(h, -h) - q) / 2.0;
		vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));
		float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);
		vec2 q_t = d + (c + b * t) * t;
		res = dot(q_t, q_t);
		sgn = cross(vec3(c + 2.0 * b * t, 0), vec3(q_t, 0)).z;
	} else {
		// 3 real roots
		float z = sqrt(-p_param);
		float v = acos(q / (p_param * z * 2.0)) / 3.0;
		float m = cos(v);
		float n = sin(v) * 1.732050808;
		vec3 t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);
		vec2 qx = d + (c + b * t.x) * t.x;
		float dx = dot(qx, qx);
		sgn = cross(vec3(c + 2.0 * b * t.x, 0), vec3(qx, 0)).z;
		vec2 qy = d + (c + b * t.y) * t.y;
		float dy = dot(qy, qy);
		if (dy < dx) {
			dx = dy;
			sgn = cross(vec3(c + 2.0 * b * t.y, 0), vec3(qy, 0)).z;
		}
		vec2 qz = d + (c + b * t.z) * t.z;
		float dz = dot(qz, qz);
		if (dz < dx) {
			dx = dz;
			sgn = cross(vec3(c + 2.0 * b * t.z, 0), vec3(qz, 0)).z;
		}
		res = dx;
	}

	return sqrt(res) * sign(sgn);
}

// Compute minimum distance from point to glyph outline
// Returns vec3 with distances for 3 edge subsets (R, G, B channels)
vec3 computeMSDF(vec2 p) {
	// Initialize distances to infinity
	vec3 minDist = vec3(1e10);

	// For multi-channel, we assign edges to channels based on their angle
	// This helps preserve sharp corners better than single-channel SDF

	uint edgeIdx = 0;

	for (uint c = 0; c < outline.contourCount; c++) {
		OutlineContour contour = outline.contours[c];
		uint numPoints = contour.pointCount;

		if (numPoints < 2) continue;

		// Process each edge in the contour
		for (uint i = 0; i < numPoints; i++) {
			uint next = (i + 1) % numPoints;
			OutlinePoint p0 = contour.points[i];
			OutlinePoint p1 = contour.points[next];

			float dist;

			// Check if we have a quadratic Bezier (off-curve control point)
			if (p1.onCurve == 0 && i + 2 < numPoints) {
				OutlinePoint p2 = contour.points[(i + 2) % numPoints];
				dist = sdBezier(p, p0.pos, p1.pos, p2.pos);
				i++; // Skip control point in next iteration
			} else {
				// Linear segment
				dist = sdSegment(p, p0.pos, p1.pos);
			}

			// Assign to channel based on edge index (simple round-robin)
			uint channel = edgeIdx % 3;
			minDist[channel] = min(minDist[channel], abs(dist));

			edgeIdx++;
		}
	}

	return minDist;
}

void main() {
	// Get pixel coordinates
	uvec2 pixelCoord = gl_GlobalInvocationID.xy;

	// Check bounds
	if (pixelCoord.x >= params.outputWidth || pixelCoord.y >= params.outputHeight) {
		return;
	}

	// Convert pixel to normalized glyph space (0-1)
	vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(params.outputWidth, params.outputHeight);

	// Compute multi-channel signed distance
	vec3 msdf = computeMSDF(uv);

	// Convert distance to pixel units and normalize
	// pxRange controls the spread of the distance field
	msdf = msdf * float(max(params.outputWidth, params.outputHeight)) / params.pxRange;

	// Map to 0-1 range (0.5 = surface, <0.5 = inside, >0.5 = outside)
	msdf = clamp(msdf * 0.5 + 0.5, 0.0, 1.0);

	// Write RGB MSDF output (alpha = 1.0)
	imageStore(outputMSDF, ivec2(pixelCoord), vec4(msdf, 1.0));
}
